<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Test JSON Export</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 1000px;
      margin: 20px auto;
      padding: 20px;
      background: #f5f5f5;
    }
    .container {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    h1 {
      color: #333;
      margin-bottom: 20px;
    }
    .test-section {
      margin-bottom: 30px;
    }
    button {
      padding: 10px 20px;
      background: #4285f4;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      margin-right: 10px;
    }
    button:hover {
      background: #357ae8;
    }
    pre {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 4px;
      overflow-x: auto;
      max-height: 600px;
      overflow-y: auto;
    }
    .label {
      font-weight: bold;
      margin-bottom: 10px;
      color: #555;
    }
    .success {
      color: #22c55e;
      font-weight: bold;
    }
    .error {
      color: #ef4444;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ðŸ§ª Test Platform JSON Export</h1>
    
    <div class="test-section">
      <div class="label">Step 1: Load Test State</div>
      <button onclick="loadTestState()">Load Sample Scraper Data</button>
      <div id="load-result"></div>
    </div>

    <div class="test-section">
      <div class="label">Step 2: Generate Platform JSON</div>
      <button onclick="testExport()">Generate JSON</button>
      <button onclick="downloadJSON()">Download JSON File</button>
      <div id="export-result"></div>
    </div>

    <div class="test-section">
      <div class="label">Generated JSON Output:</div>
      <pre id="json-output"></pre>
    </div>
  </div>

  <script>
    // Test state similar to what extension would have
    let state = {
      metadata: {
        jurisdiction: 'Honolulu',
        stateCode: 'HI',
        level: 'local',
        baseUrl: 'https://www.honolulu.gov',
        startUrl: 'https://www.honolulu.gov/clerk/clk-council-calendar/',
        requiresPuppeteer: false,
        notes: 'Test scraper'
      },
      calendarStructure: {
        'event-container': [{
          selector: '.calendar-events',
          xpath: null
        }],
        'event-item': [{
          selector: '.event-item',
          xpath: null
        }],
        'next-button': [{
          selector: '.next-month-btn',
          xpath: null,
          comment: 'Navigate to next month'
        }],
        'prev-button': [{
          selector: '.prev-month-btn',
          xpath: null
        }]
      },
      eventFields: {
        'event-name': [
          {
            selector: '.event-card',
            actionType: 'click',
            comment: 'Click event card to open modal'
          },
          {
            selector: '.modal-title h2',
            actionType: 'extract',
            comment: 'Extract title from modal'
          }
        ],
        'event-date': [
          {
            selector: '.event-date',
            actionType: 'extract',
            comment: 'Extract date from event card'
          }
        ],
        'event-time': [
          {
            selector: '.event-time',
            actionType: 'extract'
          }
        ],
        'event-url': [
          {
            selector: '.event-card a',
            actionType: 'extract',
            attribute: 'href',
            comment: 'Link to event details'
          }
        ]
      },
      detailsPage: {
        'details-description': [
          {
            selector: '.event-description',
            actionType: 'extract',
            comment: 'Full description'
          }
        ]
      }
    };

    function loadTestState() {
      const result = document.getElementById('load-result');
      result.innerHTML = '<span class="success">âœ“ Test state loaded successfully!</span>';
    }

    // Copy the generateJSON function from popup.js
    function generateJSON() {
      // Convert extension state to platform JSON format
      const config = {
        name: `${state.metadata.jurisdiction || 'Unknown'} ${state.metadata.level || 'Local'} Calendar`,
        description: `Legislative calendar scraper for ${state.metadata.jurisdiction || 'Unknown'}`,
        jurisdiction: state.metadata.jurisdiction,
        stateCode: state.metadata.stateCode,
        level: state.metadata.level,
        baseUrl: state.metadata.baseUrl,
        startUrl: state.metadata.startUrl || state.metadata.baseUrl,
        requiresPuppeteer: state.metadata.requiresPuppeteer === true || state.metadata.requiresPuppeteer === 'yes',
        active: true,
        metadata: {
          notes: state.metadata.notes || undefined,
          createdWith: 'Chrome Extension Scraper Builder'
        },
        pageStructures: [],
        navigationSteps: []
      };

      // Add navigation steps for calendar pagination
      let navStepOrder = 1;
      if (state.calendarStructure['next-button'] && Array.isArray(state.calendarStructure['next-button']) && state.calendarStructure['next-button'].length > 0) {
        state.calendarStructure['next-button'].forEach((step, idx) => {
          config.navigationSteps.push({
            stepOrder: navStepOrder++,
            stepType: 'click',
            selector: step.selector,
            xpath: step.xpath || undefined,
            comment: step.comment || `Next month button - step ${idx + 1}`
          });
        });
      }

      // Create calendar page structure
      const calendarPage = {
        pageType: 'calendar',
        pageName: 'Calendar View',
        hasPagination: !!(state.calendarStructure['next-button'] || state.calendarStructure['prev-button']),
        fields: []
      };

      // Add container/item selectors if present
      if (state.calendarStructure['event-container'] && Array.isArray(state.calendarStructure['event-container']) && state.calendarStructure['event-container'].length > 0) {
        calendarPage.containerSelector = state.calendarStructure['event-container'][0].selector;
      }
      if (state.calendarStructure['event-item'] && Array.isArray(state.calendarStructure['event-item']) && state.calendarStructure['event-item'].length > 0) {
        calendarPage.itemSelector = state.calendarStructure['event-item'][0].selector;
      }
      if (state.calendarStructure['next-button'] && Array.isArray(state.calendarStructure['next-button']) && state.calendarStructure['next-button'].length > 0) {
        calendarPage.nextButtonSelector = state.calendarStructure['next-button'][0].selector;
      }
      if (state.calendarStructure['prev-button'] && Array.isArray(state.calendarStructure['prev-button']) && state.calendarStructure['prev-button'].length > 0) {
        calendarPage.prevButtonSelector = state.calendarStructure['prev-button'][0].selector;
      }

      // Convert event fields
      let fieldOrder = 1;
      Object.entries(state.eventFields).forEach(([key, steps]) => {
        if (!Array.isArray(steps) || steps.length === 0) return;
        
        const fieldName = key.replace('event-', '').replace(/-/g, '_');
        const field = {
          fieldName: fieldName,
          fieldType: inferFieldType(fieldName),
          fieldOrder: fieldOrder++,
          isRequired: ['name', 'date', 'title'].includes(fieldName),
          transformation: fieldName.includes('date') ? 'parse_date' : (fieldName.includes('name') || fieldName.includes('title') ? 'trim' : undefined),
          comment: `${fieldName} field`,
          selectorSteps: steps.map((step, idx) => ({
            stepOrder: idx + 1,
            actionType: step.actionType || 'extract',
            selector: step.selector,
            xpath: step.xpath || undefined,
            attributeName: step.attribute || undefined,
            waitAfter: step.actionType === 'click' ? 500 : undefined,
            comment: step.comment || undefined
          }))
        };
        calendarPage.fields.push(field);
      });

      config.pageStructures.push(calendarPage);

      // Create detail page structure if there are detail page fields
      const detailFields = [];
      let detailFieldOrder = 1;
      Object.entries(state.detailsPage || {}).forEach(([key, steps]) => {
        if (!Array.isArray(steps) || steps.length === 0) return;
        
        const fieldName = key.replace('details-', '').replace(/-/g, '_');
        const field = {
          fieldName: fieldName,
          fieldType: inferFieldType(fieldName),
          fieldOrder: detailFieldOrder++,
          isRequired: false,
          comment: `${fieldName} from detail page`,
          selectorSteps: steps.map((step, idx) => ({
            stepOrder: idx + 1,
            actionType: step.actionType || 'extract',
            selector: step.selector,
            xpath: step.xpath || undefined,
            attributeName: step.attribute || undefined,
            waitAfter: step.actionType === 'click' ? 500 : undefined,
            comment: step.comment || undefined
          }))
        };
        detailFields.push(field);
      });

      if (detailFields.length > 0) {
        config.pageStructures.push({
          pageType: 'detail',
          pageName: 'Event Detail Page',
          fields: detailFields
        });
      }

      return config;
    }

    // Infer field type from field name
    function inferFieldType(fieldName) {
      if (fieldName.includes('date')) return 'date';
      if (fieldName.includes('url') || fieldName.includes('link')) return 'url';
      if (fieldName.includes('html') || fieldName.includes('description')) return 'html';
      if (fieldName.includes('number') || fieldName.includes('count')) return 'number';
      return 'text';
    }

    function testExport() {
      try {
        const json = generateJSON();
        const output = document.getElementById('json-output');
        const result = document.getElementById('export-result');
        
        output.textContent = JSON.stringify(json, null, 2);
        result.innerHTML = '<span class="success">âœ“ JSON generated successfully!</span>';
        
        // Validate structure
        const validation = validateJSON(json);
        if (validation.valid) {
          result.innerHTML += '<br><span class="success">âœ“ JSON structure is valid</span>';
        } else {
          result.innerHTML += `<br><span class="error">âœ— Validation errors: ${validation.errors.join(', ')}</span>`;
        }
      } catch (error) {
        document.getElementById('export-result').innerHTML = 
          `<span class="error">âœ— Error: ${error.message}</span>`;
      }
    }

    function downloadJSON() {
      try {
        const json = generateJSON();
        const blob = new Blob([JSON.stringify(json, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        const safeName = (state.metadata.jurisdiction || 'scraper')
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, '-')
          .replace(/^-|-$/g, '');
        a.download = `${safeName}-scraper.json`;
        a.click();
        
        URL.revokeObjectURL(url);
        
        document.getElementById('export-result').innerHTML += 
          '<br><span class="success">âœ“ File downloaded!</span>';
      } catch (error) {
        document.getElementById('export-result').innerHTML = 
          `<span class="error">âœ— Download error: ${error.message}</span>`;
      }
    }

    function validateJSON(json) {
      const errors = [];
      
      // Check required fields
      if (!json.name) errors.push('Missing name');
      if (!json.baseUrl) errors.push('Missing baseUrl');
      if (!json.startUrl) errors.push('Missing startUrl');
      
      // Check page structures
      if (!json.pageStructures || json.pageStructures.length === 0) {
        errors.push('No page structures defined');
      }
      
      return {
        valid: errors.length === 0,
        errors
      };
    }
  </script>
</body>
</html>
